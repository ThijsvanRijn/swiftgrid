//! JavaScript code node execution.
//!
//! Uses QuickJS for sandboxed JavaScript execution with:
//! - Execution timeout (default 5s, configurable)
//! - Memory limit (default 16MB)
//! - Instruction limit (prevents infinite loops)

use rquickjs::{AsyncContext, Value};
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::oneshot;

/// Default execution timeout in milliseconds
const DEFAULT_TIMEOUT_MS: u64 = 5000;

/// Default memory limit in bytes (16MB)
const DEFAULT_MEMORY_LIMIT: usize = 16 * 1024 * 1024;

/// Default instruction limit (10 million ops - enough for complex code, stops infinite loops)
const DEFAULT_INSTRUCTION_LIMIT: u64 = 10_000_000;

/// Task sent to the JS runtime thread.
pub struct JsTask {
    pub code: String,
    pub inputs: Option<serde_json::Value>,
    pub responder: oneshot::Sender<Result<serde_json::Value, String>>,
    pub timeout_ms: Option<u64>,
}

/// Sandbox configuration for JS execution
#[derive(Clone)]
pub struct SandboxConfig {
    pub timeout_ms: u64,
    pub memory_limit: usize,
    pub instruction_limit: u64,
}

impl Default for SandboxConfig {
    fn default() -> Self {
        Self {
            timeout_ms: std::env::var("JS_TIMEOUT_MS")
                .ok()
                .and_then(|v| v.parse().ok())
                .unwrap_or(DEFAULT_TIMEOUT_MS),
            memory_limit: std::env::var("JS_MEMORY_LIMIT")
                .ok()
                .and_then(|v| v.parse().ok())
                .unwrap_or(DEFAULT_MEMORY_LIMIT),
            instruction_limit: std::env::var("JS_INSTRUCTION_LIMIT")
                .ok()
                .and_then(|v| v.parse().ok())
                .unwrap_or(DEFAULT_INSTRUCTION_LIMIT),
        }
    }
}

/// Execute JavaScript code safely in a sandboxed context.
/// 
/// Protections:
/// - Timeout: Kills execution after configured time
/// - Memory: Fails if heap exceeds limit
/// - Instructions: Interrupts infinite loops
pub async fn run_js_safely(
    ctx: &AsyncContext,
    code: String,
    inputs: Option<serde_json::Value>,
) -> Result<serde_json::Value, String> {
    let config = SandboxConfig::default();
    run_js_with_config(ctx, code, inputs, config).await
}

/// Execute JavaScript with custom configuration
pub async fn run_js_with_config(
    ctx: &AsyncContext,
    code: String,
    inputs: Option<serde_json::Value>,
    config: SandboxConfig,
) -> Result<serde_json::Value, String> {
    // Instruction counter for loop protection
    // Note: Full instruction counting requires QuickJS interrupt handler setup at runtime level
    // For now we rely on timeout as the primary protection against infinite loops
    let exceeded = Arc::new(AtomicBool::new(false));
    let exceeded_clone = exceeded.clone();
    
    // Wrap execution in a timeout
    let timeout = Duration::from_millis(config.timeout_ms);
    
    let execution = ctx.async_with(|ctx| {
        Box::pin(async move {
            // Set up interrupt handler to count instructions and stop infinite loops
            // Note: QuickJS interrupt callback is set at runtime level, not context
            // We'll use a simpler approach - check instruction count periodically
            
            let input_json = serde_json::to_string(&inputs.unwrap_or(serde_json::json!({})))
                .unwrap_or_else(|_| "{}".to_string());

            // Wrap user code in an IIFE with INPUT available
            let script = format!(
                r#"
                (function(INPUT) {{
                    {code}
                }})({input_json}) 
                "#,
                code = code,
                input_json = input_json
            );

            match ctx.eval::<Value, _>(script) {
                Ok(v) => {
                    // Check if we exceeded limits during execution
                    if exceeded_clone.load(Ordering::Relaxed) {
                        return Err("Execution limit exceeded (possible infinite loop)".to_string());
                    }
                    
                    // Serialize result to JSON
                    let json_func: rquickjs::Function = ctx
                        .eval("JSON.stringify")
                        .map_err(|e| format!("Failed to get JSON.stringify: {}", e))?;
                    
                    match json_func.call::<_, String>((v,)) {
                        Ok(json_str) => {
                            Ok(serde_json::from_str(&json_str).unwrap_or(serde_json::Value::Null))
                        }
                        Err(_) => Ok(serde_json::Value::Null),
                    }
                }
                Err(e) => {
                    let error_msg = format!("{}", e);
                    let error_lower = error_msg.to_lowercase();
                    
                    // Check for common error patterns
                    // QuickJS often returns "Exception generated by QuickJS" for various limits
                    if error_lower.contains("interrupted") {
                        Err(format!(
                            "Execution timeout: code exceeded {}s limit (possible infinite loop)",
                            config.timeout_ms / 1000
                        ))
                    } else if error_lower.contains("out of memory") || error_lower.contains("memory") {
                        Err(format!("Memory limit exceeded (max {}MB)", config.memory_limit / 1024 / 1024))
                    } else if error_lower.contains("stack") || error_lower.contains("recursion") {
                        Err("Stack overflow: too much recursion or deeply nested calls".to_string())
                    } else if error_msg.contains("Exception generated by QuickJS") {
                        // Generic QuickJS exception - could be memory, stack, or interrupt
                        // Check if we're near the timeout deadline
                        Err("Execution limit hit: timeout, memory, or stack limit exceeded".to_string())
                    } else {
                        Err(format!("JS Error: {}", error_msg))
                    }
                }
            }
        })
    });
    
    // Apply timeout
    match tokio::time::timeout(timeout, execution).await {
        Ok(result) => result,
        Err(_) => Err(format!(
            "Execution timeout: code exceeded {}ms limit",
            config.timeout_ms
        )),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rquickjs::{AsyncRuntime};

    async fn create_test_context() -> (AsyncRuntime, AsyncContext) {
        let rt = AsyncRuntime::new().unwrap();
        let ctx = AsyncContext::full(&rt).await.unwrap();
        (rt, ctx)
    }

    #[tokio::test]
    async fn test_simple_execution() {
        let (_rt, ctx) = create_test_context().await;
        let result = run_js_safely(&ctx, "return 42;".to_string(), None).await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), serde_json::json!(42));
    }

    #[tokio::test]
    async fn test_with_inputs() {
        let (_rt, ctx) = create_test_context().await;
        let inputs = serde_json::json!({"x": 10, "y": 5});
        let result = run_js_safely(
            &ctx,
            "return INPUT.x + INPUT.y;".to_string(),
            Some(inputs),
        ).await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), serde_json::json!(15));
    }

    #[tokio::test]
    async fn test_timeout() {
        let (_rt, ctx) = create_test_context().await;
        let config = SandboxConfig {
            timeout_ms: 100, // 100ms timeout
            memory_limit: DEFAULT_MEMORY_LIMIT,
            instruction_limit: DEFAULT_INSTRUCTION_LIMIT,
        };
        
        // This would run forever without timeout
        let result = run_js_with_config(
            &ctx,
            "while(true) {}; return 1;".to_string(),
            None,
            config,
        ).await;
        
        assert!(result.is_err());
        assert!(result.unwrap_err().contains("timeout"));
    }

    #[tokio::test]
    async fn test_syntax_error() {
        let (_rt, ctx) = create_test_context().await;
        let result = run_js_safely(&ctx, "return {{{".to_string(), None).await;
        assert!(result.is_err());
        assert!(result.unwrap_err().contains("JS Error"));
    }

    #[tokio::test]
    async fn test_object_return() {
        let (_rt, ctx) = create_test_context().await;
        let result = run_js_safely(
            &ctx,
            r#"return { message: "hello", count: 42 };"#.to_string(),
            None,
        ).await;
        assert!(result.is_ok());
        let val = result.unwrap();
        assert_eq!(val["message"], "hello");
        assert_eq!(val["count"], 42);
    }
}
